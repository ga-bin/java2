package com.yedam.java.ch0701_01;

public class ChildTest2 {

	public static void main(String[] args) {
		GrandPa pa = new Father();
		// 부모타입인 grandpa로 father 인스턴스 생성
		pa.method();
		// 자식타입이 부모타입으로 인스턴스 생성할 때는 자식타입의 메소드 쓸 수 없다
		// father 메소드 나옴
		// 자식클래스와 부모클래스의 인스턴스가 모두 있을 때 오버라이딩 시 자식 클래스의 메소드가 우선순위가 높기 때문
		// 부모데이터타입으로 자식 인스턴스 생성하든, 자식데이터타입으로 자식 인스턴스 생성하든
		// 오버라이딩 시 자식 클래스의 우선순위가 높다
		// 인스턴스는 온전히 있고 타입만 변하는 것이기 때문에 형변환시 데이터 손실 없다
		// 부모클래스는 여러개의 자식클래스가 있기 때문에 부모클래스에서 자식클래스로변경했을 시
		// 어떤 자식클래스로 변경해야하는지 확신할 수 없다. 그래서 강제 형변환이라고 하는거고 자바에서
		// 권유하지 않음
		// 자바는 기본적으로 데이터 타입보고 클래스에 있는 메소드를 요청하는데, 자식클래스로 잘못 형변환
		// 됐을 경우 변경된 데이터타입의 메소드들 중 그 기능을 가진 것이 없으면 오류가 발생하기 때문
//		pa = new Uncle();
		// 오류안난다, 실제로 new Uncle을 pa가 가지고 있다고 하더라도 자바는 타입을 우선적으로 보기 때문에
		// GrandPa를 데이터타입으로 가지고 있는 pa는 밑에서 father로 강제 형변환 가능
		// 문법적으로는 오류가 없다, 실행시 가지고 있는게 uncle이어서 오류가 난다
		// 그래서 부모타입을 자식타입으로 강제형변환 갈 경우 instanceof 메소드 사용한다
		System.out.println();
		if(pa instanceof Father) {
		Father fa = (Father) pa;
		fa.method();
		fa.method2();
		} else {
			System.out.println("pa변수가 가지고 있는 인스턴스는 father가 아닙니다");
		}
		// 강제 형변환 하면 쓸 수 있음
		// 강제 형변환은 원래 자식클래스였던 것이 부모클래스로 생성되고 다시 자식으로 형변환
		// 할때만 사용가능하다
	}

}
